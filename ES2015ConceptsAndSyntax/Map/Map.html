<script type="text/javascript">
// Map

// The Map object holds key-value pairs. Any value (both objects and primitive values) may be used as either a key or a value.

// Syntax
// new Map([iterable])

// Parameters
// iterable
// An Array or other iterable object whose elements are key-value pairs (arrays with two elements, e.g. [[ 1, 'one' ],[ 2, 'two' ]]).
// Each key-value pair is added to the new Map; null values are treated as undefined.

// Description
// A Map object iterates its elements in insertion order — a for...of loop returns an array of [key, value] for each iteration.
// It should be noted that a Map which is a map of an object, especially a dictionary of dictionaries, will only map to the object's insertion order—which is random and not ordered.

// Key equality
// Key equality is based on the "SameValueZero" algorithm:
// NaN is considered the same as NaN (even though NaN !== NaN) and all other values are considered equal according to the semantics of the === operator.
// In the current ECMAScript specification -0 and +0 are considered equal, although this was not so in earlier drafts.
// See "Value equality for -0 and 0" in the browser compatibility table for details.

// Objects and maps compared
// Objects are similar to Maps in that both let you set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key.
// Because of this (and because there were no built-in alternatives), Objects have been used as Maps historically; however, there are important differences that make using a Map preferable in certain cases:
// The keys of an Object are Strings and Symbols, whereas they can be any value for a Map, including functions, objects, and any primitive.
// You can get the size of a Map easily with the size property, while the number of properties in an Object must be determined manually.
// A Map is an iterable and can thus be directly iterated, whereas iterating over an Object requires obtaining its keys in some fashion and iterating over them.
// An Object has a prototype, so there are default keys in the map that could collide with your keys if you're not careful.
// As of ES5 this can be bypassed by using map = Object.create(null), but this is seldom done.
// A Map may perform better in scenarios involving frequent addition and removal of key pairs.

// Properties
// Map.length
//  The value of the length property is 0.
// get Map[@@species]
//  The constructor function that is used to create derived objects.
// Map.prototype
//  Represents the prototype for the Map constructor. Allows the addition of properties to all Map objects.

// Map instances
// All Map instances inherit from Map.prototype.

// Properties
// Map.prototype.constructor
//  Returns the function that created an instance's prototype. This is the Map function by default.
// Map.prototype.size
//  Returns the number of key/value pairs in the Map object.

// Methods
// Map.prototype.clear()
//  Removes all key/value pairs from the Map object.
// Map.prototype.delete(key)
//  Returns true if an element in the Map object existed and has been removed, or false if the element does not exist. Map.prototype.has(key) will return false afterwards.
// Map.prototype.entries()
//  Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.
// Map.prototype.forEach(callbackFn[, thisArg])
//  Calls callbackFn once for each key-value pair present in the Map object, in insertion order. If a thisArg parameter is provided to forEach, it will be used as the this value for each callback.
// Map.prototype.get(key)
//  Returns the value associated to the key, or undefined if there is none.
// Map.prototype.has(key)
//  Returns a boolean asserting whether a value has been associated to the key in the Map object or not.
// Map.prototype.keys()
//  Returns a new Iterator object that contains the keys for each element in the Map object in insertion order.
// Map.prototype.set(key, value)
//  Sets the value for the key in the Map object. Returns the Map object.
// Map.prototype.values()
//  Returns a new Iterator object that contains the values for each element in the Map object in insertion order.
// Map.prototype[@@iterator]()
//  Returns a new Iterator object that contains an array of [key, value] for each element in the Map object in insertion order.

// Examples

// Using the Map object
var myMap = new Map();
var keyString = 'a string',
    keyObj = {},
    keyFunc = function() {};
// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, 'value associated with keyObj');
myMap.set(keyFunc, 'value associated with keyFunc');
console.log("myMap.size|"+myMap.size); // 3
// getting the values
console.log("myMap.get(keyString)|"+myMap.get(keyString));      // "value associated with 'a string'"
console.log("myMap.get(keyObj)|"+myMap.get(keyObj));            // "value associated with keyObj"
console.log("myMap.get(keyFunc)|"+myMap.get(keyFunc));          // "value associated with keyFunc"
console.log("myMap.get('a string')|"+myMap.get('a string'));     // "value associated with 'a string'"
                                                                // because keyString === 'a string'
console.log("myMap.get({})|"+myMap.get({}));                      // undefined, because keyObj !== {}
console.log("myMap.get(function() {})"+myMap.get(function() {})); // undefined, because keyFunc !== function () {}

// Using NaN as Map keys
// NaN can also be used as a key. Even though every NaN is not equal to itself (NaN !== NaN is true), the following example works because NaNs are indistinguishable from each other:
var myMap2 = new Map();
myMap2.set(NaN, 'not a number');
console.log("myMap2.get(NaN)|"+myMap2.get(NaN)); // "not a number"
var otherNaN = Number('foo');
console.log("myMap2.get(otherNaN)|"+myMap2.get(otherNaN)); // "not a number"

// Iterating Maps with for..of
// Maps can be iterated using a for..of loop:
var myMap = new Map();
    myMap.set(0, 'zero');
    myMap.set(1, 'one');
for (var [key, value] of myMap) {
    console.log(key + ' = ' + value);
}
// 0 = zero
// 1 = one
for (var key of myMap.keys()) {
    console.log(key);
}
// 0
// 1
for (var value of myMap.values()) {
    console.log(value);
}
// zero
// one
for (var [key, value] of myMap.entries()) {
    console.log(key + ' = ' + value);
}
// 0 = zero
// 1 = one

// Iterating Maps with forEach()
// Maps can be iterated using the forEach() method:
myMap.forEach(function(value, key) {
    console.log(key + ' = ' + value);
});
// Will show 2 logs; first with "0 = zero" and second with "1 = one"

// Relation with Array objects
var kvArray = [['key1', 'value1'], ['key2', 'value2']];
// Use the regular Map constructor to transform a 2D key-value Array into a map
var myMap = new Map(kvArray);
console.log("myMap.get('key1')|"+myMap.get('key1')); // returns "value1"
// Use the Array.from function to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray
// Or use the keys or values iterators and convert them to an array
console.log(Array.from(myMap.keys())); // Will show ["key1", "key2"]

</script>